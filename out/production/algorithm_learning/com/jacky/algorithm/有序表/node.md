## 搜索二叉树


搜索二叉树一定要说明以什么标准来排序

经典的搜索二叉树，树上没有重复的用来排序的key值

如果有重复节点的需求，可以在一个节点内部增加数据项


## 搜索二叉树查询key（查询某个key存在还是不存在）


1）如果当前节点的value==key，返回true

2）如果当前节点的value<key，当前节点向左移动

3）如果当前节点的value>key，当前节点向右移动

4）如果当前节点变成null，返回false


##搜索二叉树插入新的key

和查询过程一样，但当前节点滑到空的时候，就插入在这里

## 搜索二叉树删除key

0）先找到key所在的节点

1）如果该节点没有左孩子、没有右孩子，直接删除即可

2）如果该节点有左孩子、没有右孩子，直接用左孩子顶替该节点

3）如果该节点没有左孩子、有右孩子，直接用右孩子顶替该节点

4）如果该节点有左孩子、有右孩子，用该节点后继节点顶替该节点


## 搜索二叉树特别不讲究


1）基础的搜索二叉树，添加、删除时候不照顾平衡性

2）数据状况很差时，性能就很差


给搜索二叉树引入两个动作：左旋、右旋



## AVL树、SB树、红黑树的共性


1）都是搜索二叉树

2）插入、删除、查询（一切查询）搜索二叉树怎么做，这些结构都这么做

3）使用调整的基本动作都只有左旋、右旋

4）插入、删除时，从最底层被影响到的节点开始，对往上路径的节点做平衡性检查

5）因为只对一条向上路径的每个节点做O(1)的检查和调整，所以可以做到O(logN)

## AVL树、SB树、红黑树的不同

1）平衡性的约束不同

AVL树最严格、SB树稍宽松、红黑树最宽松

2）插入、删除和搜索二叉树一样，但是额外，做各自的平衡性调整。各自的平衡性调整所使用的动作都是左旋或者右旋

## AVL树

1）最严格的平衡性，任何节点左树高度和右树高度差不超过1

2）往上沿途检查每个节点时，都去检查四种违规情况：LL、RR、LR、RL

3）不同情况虽然看起来复杂，但是核心点是：
LL（做一次右旋）、RR（做一次左旋）
LR和RL（利用旋转让底层那个上到顶部）


## SB树（size-balance-tree）


1）让每一个叔叔节点为头的数，节点个数都不少于其任何一个侄子节点

2）也是从底层被影响节点开始向上做路径每个节点检查

3）与AVL树非常像，也是四种违规类型：LL、RR、LR、RL

4）与AVL树非常像，核心点是：

LL（做一次右旋）、RR（做一次左旋）
LR和RL（利用旋转让底层那个上到顶部）

5）与AVL树不同的是，每轮经过调整后，谁的孩子发生变化了，谁就再查

## SB树在使用时候的改进

1）删除时候可以不用检查

2）就把平衡性的调整放在插入的时候

3）因为这种只要变就递归的特性，别的树没有

4）可以在节点上封装别的数据项，来增加功能


## 跳表（skiplist）

1）结构上根本和搜索二叉树无关

2）利用随机概率分布来使得高层索引可以无视数据规律，做到整体性能优良

3）思想是所有有序表中最先进的

4）结构简单就是多级单链表

## 聊聊红黑树

1）平衡性规定非常诡异

2）平衡性调整最为复杂

3）优点在于每次插入删除扰动较好，但是在今天看来这个优势也极其微弱了

原因：贪图扰动小的话，B+树、2-3-4树可能更好，还是那句话，到底图什么

4）除此之外，红黑树并不比AVL树、SB树、跳表更加优秀

5）面试上遇到，说清楚道理，不行就举报


## 需要改写有序表的题目一

给定一个数组arr，和两个整数a和b（a<=b）
求arr中有多少个子数组，累加和在[a,b]这个范围上
返回达标的子数组数量

## 需要改写有序表的题目二


有一个滑动窗口（讲过的）：

1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧
2）任何一步都可能R往右动，表示某个数进了窗口
3）任何一步都可能L往右动，表示某个数出了窗口

想知道每一个窗口状态的中位数



##改写有序表的题目核心点

1）分析增加什么数据项可以支持题目

2）有序表一定要保持内部参与排序的key不重复

3）增加这个数据项了，在平衡性调整时，保证这个数据项也能更新正确

4）做到上面3点，剩下就是搜索二叉树怎么实现你想要的接口的问题了




